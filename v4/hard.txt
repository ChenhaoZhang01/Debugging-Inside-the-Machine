{"prompt":"Hard 01 (procedures + lists): This procedure should return the last element of numbers. What is the bug?","code":"PROCEDURE getLast(numbers) {\n  RETURN(numbers[LENGTH(numbers) + 1])\n}\nvalues ← [3, 5, 7]\nresult ← getLast(values)\nDISPLAY(result)","choices":["It uses LENGTH(numbers) + 1, which refers past the end of the list","It should call LENGTH(values) instead of LENGTH(numbers)","The RETURN must be after a loop over numbers","values must have at least 10 elements for LENGTH to work"],"correctIndex":0}
{"prompt":"Hard 02 (procedures + lists): addToEnd is supposed to APPEND value to the end of list. What is the bug?","code":"PROCEDURE addToEnd(list, value) {\n  INSERT(list, LENGTH(list), value)\n}\nnums ← [1, 2, 3]\naddToEnd(nums, 4)\nDISPLAY(nums)","choices":["INSERT at LENGTH(list) places value before the last element; APPEND or INSERT at LENGTH(list) + 1 is needed","INSERT should only be used when the list is empty","The procedure must RETURN list for the change to happen","value should be added with REMOVE, not INSERT"],"correctIndex":0}
{"prompt":"Hard 03 (procedures + lists): This procedure should remove the first item from list. What is the bug?","code":"PROCEDURE removeFirst(list) {\n  REMOVE(list, 0)\n}\nitems ← [\"a\", \"b\", \"c\"]\nremoveFirst(items)\nDISPLAY(items[1])","choices":["Index 0 is invalid in AP CSP lists, which start at index 1","It should use INSERT instead of REMOVE for the first element","items must be a list of numbers rather than strings","The procedure should RETURN items instead of modifying it"],"correctIndex":0}
{"prompt":"Hard 04 (procedures + lists): doubleAll is meant to change nums so every element is doubled. Why doesn’t it work?","code":"PROCEDURE doubleAll(numbers) {\n  FOR EACH value IN numbers {\n    value ← value * 2\n  }\n}\nnums ← [1, 2, 3]\ndoubleAll(nums)\nDISPLAY(nums[1])","choices":["Reassigning the loop variable value does not update the elements stored in numbers","The FOR EACH loop must be outside the PROCEDURE","numbers must be initialized inside doubleAll, not passed as a parameter","FOR EACH can only be used with strings, not numbers"],"correctIndex":0}
{"prompt":"Hard 05 (procedures + lists): sumList is supposed to return the sum of the list. What is the bug?","code":"PROCEDURE sumList(numbers) {\n  total ← 0\n  FOR EACH num IN numbers {\n    total ← total + num\n  }\n}\nvalues ← [2, 4, 6]\nresult ← sumList(values)\nDISPLAY(result)","choices":["The procedure never RETURNS total, so result has no value from sumList","total should be declared as a list, not a number","FOR EACH must not be used inside PROCEDUREs","sumList should be called before values is created"],"correctIndex":0}
{"prompt":"Hard 06 (procedures + lists): average is supposed to compute the mean of the list. What loop bug prevents it from working?","code":"PROCEDURE average(numbers) {\n  total ← 0\n  index ← 1\n  REPEAT UNTIL (index > LENGTH(numbers)) {\n    total ← total + numbers[index]\n  }\n  RETURN(total / LENGTH(numbers))\n}\nvalues ← [5, 7, 9]\nDISPLAY(average(values))","choices":["index is never updated inside the loop, so the REPEAT UNTIL condition never becomes true","The loop condition must be index ≥ LENGTH(numbers) instead of >","total should start at 1 to avoid dividing by zero","RETURN must appear before the loop to give a value"],"correctIndex":0}
{"prompt":"Hard 07 (procedures + lists): This procedure must return the first number greater than limit. What bug can skip valid answers?","code":"PROCEDURE findFirstGreater(numbers, limit) {\n  index ← 1\n  REPEAT UNTIL (index > LENGTH(numbers)) {\n    IF (numbers[index] > limit) {\n      RETURN(numbers[index])\n    }\n    index ← index + 2\n  }\n  RETURN(-1)\n}\nvalues ← [3, 4, 5, 6]\nresult ← findFirstGreater(values, 4)\nDISPLAY(result)","choices":["index increases by 2, so some elements are never checked at all","The IF should test numbers[index] ≥ limit instead of > limit","The final RETURN must be inside the loop instead of after it","numbers must be sorted for this procedure to work"],"correctIndex":0}
{"prompt":"Hard 08 (procedures + lists): appendTwice is meant to add value to list twice. What is the bug in the call?","code":"PROCEDURE appendTwice(list, value) {\n  APPEND(list, value)\n  APPEND(list, value)\n}\nnums ← []\nappendTwice(nums)\nDISPLAY(LENGTH(nums))","choices":["The call to appendTwice is missing the value argument","appendTwice must RETURN the list instead of modifying it","nums cannot be empty when passed to the procedure","LENGTH cannot be used on lists created in procedures"],"correctIndex":0}
{"prompt":"Hard 09 (procedures + lists): maxValue should return the largest number, but it always returns the last one. Why?","code":"PROCEDURE maxValue(numbers) {\n  max ← numbers[1]\n  FOR EACH n IN numbers {\n    max ← n\n  }\n  RETURN(max)\n}\nvalues ← [2, 10, 5]\nDISPLAY(maxValue(values))","choices":["max is overwritten with every element; it should be updated only when n > max","max should start at 0 for all inputs","The FOR EACH loop should go in reverse order","RETURN(max) must be inside the FOR EACH loop"],"correctIndex":0}
{"prompt":"Hard 10 (procedures + lists): countTarget should return how many times target appears. What is the bug?","code":"PROCEDURE countTarget(list, target) {\n  count ← 0\n  FOR EACH item IN list {\n    IF (item = target) {\n      count ← count + 1\n    }\n  }\n  RETURN(item)\n}\nvalues ← [1, 2, 1]\nDISPLAY(countTarget(values, 1))","choices":["It RETURNS item instead of the counter, so the count is never used","count should be decremented instead of incremented","The IF should compare target to list, not item","The procedure needs a second parameter for the counter"],"correctIndex":0}
{"prompt":"Hard 11 (procedures + lists): firstElement should return the first item of list, but sometimes it crashes. Why?","code":"PROCEDURE firstElement(list) {\n  RETURN(list[1])\n}\nvalues ← []\nDISPLAY(firstElement(values))","choices":["It assumes list has at least one element and does not handle the empty list case","Index 1 is only valid for lists with exactly one item","RETURN cannot be the first line of a procedure","values must be a list of strings, not an empty list"],"correctIndex":0}
{"prompt":"Hard 12 (procedures + lists): This procedure should create a copy of a list. Why is the result incorrect?","code":"PROCEDURE copyList(original) {\n  copy ← original\n  RETURN(copy)\n}\nnums ← [1, 2, 3]\nclone ← copyList(nums)\nAPPEND(clone, 4)\nDISPLAY(LENGTH(nums))","choices":["copy refers to the same list as original, so changing clone also changes nums","copyList must use INSERT instead of assignment","Lists cannot be returned from procedures in AP CSP pseudocode","APPEND cannot be used on lists returned from procedures"],"correctIndex":0}
{"prompt":"Hard 13 (procedures + lists): This procedure should swap the first and last elements of list. What is the bug?","code":"PROCEDURE swapEnds(list) {\n  temp ← list[1]\n  list[1] ← list[LENGTH(list)]\n  list[LENGTH(list)] ← list[1]\n}\nnums ← [1, 2, 3]\nswapEnds(nums)\nDISPLAY(nums[1])","choices":["The last assignment should put temp back, not list[1], so it should be list[LENGTH(list)] ← temp","The temp variable must be declared outside the procedure","LENGTH(list) cannot be called more than once in a procedure","Lists with three values cannot have their ends swapped"],"correctIndex":0}
{"prompt":"Hard 14 (procedures + lists): indexOf is supposed to return the position of target, or 0 if not found. What is the bug?","code":"PROCEDURE indexOf(list, target) {\n  index ← 1\n  REPEAT UNTIL (index > LENGTH(list)) {\n    IF (list[index] = target) {\n      RETURN(index)\n    }\n    index ← index + 1\n  }\n  RETURN(-1)\n}\nvalues ← [5, 6]\nDISPLAY(indexOf(values, 4))","choices":["It returns -1 when target is not found, but the design says it should return 0","The loop should start at index 0, not 1","The REPEAT UNTIL condition must use index ≥ LENGTH(list)","indexOf should RETURN list instead of an index"],"correctIndex":0}
{"prompt":"Hard 15 (procedures + lists): makeZeros should build a list of n zeros. What is wrong?","code":"PROCEDURE makeZeros(n) {\n  zeros ← []\n  i ← 1\n  REPEAT UNTIL (i > n) {\n    zeros[i] ← 0\n    i ← i + 1\n  }\n  RETURN(zeros)\n}\nresult ← makeZeros(3)\nDISPLAY(LENGTH(result))","choices":["It writes directly to zeros[i] instead of APPEND, which can assume valid indexes already exist","The loop should start with i ← 0, not 1","zeros must be initialized with placeholder values first","Lists that contain only zeros cannot be returned"],"correctIndex":0}
{"prompt":"Hard 16 (procedures + lists): This procedure should remove all negative numbers. Why is it buggy?","code":"PROCEDURE removeNegatives(list) {\n  index ← 1\n  REPEAT UNTIL (index > LENGTH(list)) {\n    IF (list[index] < 0) {\n      REMOVE(list, index)\n      index ← index + 1\n    }\n    index ← index + 1\n  }\n}\nnums ← [1, -2, -3, 4]\nremoveNegatives(nums)\nDISPLAY(nums)","choices":["index is increased twice after a removal, so some negative elements are skipped","The IF should check list[index] > 0 instead of < 0","REMOVE must be called with the value, not the index","The loop must run REPEAT LENGTH(list) TIMES instead of using UNTIL"],"correctIndex":0}
{"prompt":"Hard 17 (procedures + lists): joinLists should append items from listB to listA. What is the bug?","code":"PROCEDURE joinLists(listA, listB) {\n  FOR EACH item IN listB {\n    APPEND(listB, item)\n  }\n}\na ← [1, 2]\nb ← [3, 4]\njoinLists(a, b)\nDISPLAY(a)","choices":["It appends items back into listB instead of adding them into listA","The FOR EACH loop must iterate over listA, not listB","The procedure must RETURN listA for changes to be visible","APPEND cannot be used inside a procedure"],"correctIndex":0}
{"prompt":"Hard 18 (procedures + lists): getEvens should return only the even numbers. Why is its return value wrong?","code":"PROCEDURE getEvens(list) {\n  evens ← []\n  FOR EACH value IN list {\n    IF (value MOD 2 = 0) {\n      APPEND(evens, value)\n    }\n  }\n  RETURN(list)\n}\nnums ← [1, 2, 3, 4]\nresult ← getEvens(nums)\nDISPLAY(LENGTH(result))","choices":["It returns the original list instead of the evens list","The IF condition should use value MOD 2 ≠ 0","APPEND is adding values in the wrong order","The loop must stop after the first even value"],"correctIndex":0}
{"prompt":"Hard 19 (procedures + lists): reverse should return the list in reverse order, but it doesn’t. Why?","code":"PROCEDURE reverse(list) {\n  reversed ← []\n  index ← 1\n  REPEAT UNTIL (index > LENGTH(list)) {\n    APPEND(reversed, list[index])\n    index ← index + 1\n  }\n  RETURN(list)\n}\nnums ← [1, 2, 3]\nDISPLAY(reverse(nums))","choices":["It returns the original list instead of the reversed list","The loop should count down instead of up","APPEND should insert at the front of reversed","reversed must be the same variable as list"],"correctIndex":0}
{"prompt":"Hard 20 (procedures + lists): totalLength should return the total number of elements in both lists. What is the bug?","code":"PROCEDURE totalLength(listA, listB) {\n  RETURN(LENGTH(listA) + LENGTH(listA))\n}\na ← [1, 2]\nb ← [3, 4, 5]\nDISPLAY(totalLength(a, b))","choices":["It adds LENGTH(listA) twice and never uses LENGTH(listB)","The RETURN should be stored in a variable before being used","LENGTH cannot be called more than once in a procedure","The lists must be the same length for totalLength to work"],"correctIndex":0}
{"prompt":"Hard 21 (procedures + lists): contains should return TRUE if list has target. Why is it incorrect?","code":"PROCEDURE contains(list, target) {\n  FOR EACH item IN list {\n    IF (item = target) {\n      RETURN(TRUE)\n    }\n    ELSE {\n      RETURN(FALSE)\n    }\n  }\n}\nvalues ← [1, 2, 3]\nDISPLAY(contains(values, 3))","choices":["It returns FALSE as soon as the first item is not target, without checking the rest of the list","The ELSE branch should come after the loop instead of inside it","TRUE must be in quotes to be returned","FOR EACH cannot be combined with RETURN statements"],"correctIndex":0}
{"prompt":"Hard 22 (procedures + lists): scale should multiply each item in list by factor. Why doesn’t list change?","code":"PROCEDURE scale(list, factor) {\n  FOR EACH item IN list {\n    item ← item * factor\n  }\n}\nnums ← [1, 2, 3]\nscale(nums, 2)\nDISPLAY(nums[1])","choices":["Reassigning the loop variable item does not modify the underlying elements of list","factor must be appended into list before the loop","The procedure needs to RETURN list to apply changes","FOR EACH must use an index variable, not an element variable"],"correctIndex":0}
{"prompt":"Hard 23 (procedures + lists): findAllPositions should add all indices where target appears. What is the bug?","code":"PROCEDURE findAllPositions(list, target) {\n  positions ← []\n  index ← 1\n  REPEAT UNTIL (index > LENGTH(list)) {\n    IF (list[index] = target) {\n      APPEND(positions, index)\n      RETURN(positions)\n    }\n    index ← index + 1\n  }\n  RETURN(positions)\n}\nvalues ← [1, 2, 1, 2]\nDISPLAY(findAllPositions(values, 2))","choices":["It returns as soon as it finds the first match, so later matches are never collected","positions must start with one value already stored","The APPEND should add list[index], not index","The loop condition should be index ≥ LENGTH(list) instead of >"],"correctIndex":0}
{"prompt":"Hard 24 (procedures + lists): incrementAll should add 1 to every element and return the result. What is the bug?","code":"PROCEDURE incrementAll(list) {\n  index ← 1\n  REPEAT UNTIL (index > LENGTH(list)) {\n    list[index] ← list[index] + 1\n    index ← index + 1\n  }\n}\nnums ← [1, 2]\nresult ← incrementAll(nums)\nDISPLAY(result[1])","choices":["The procedure never returns the modified list, so result does not refer to anything","index should start at 0 for lists","The loop should use FOR EACH instead of a numeric index","It must use APPEND instead of assigning list[index]"],"correctIndex":0}
{"prompt":"Hard 25 (procedures + lists): makeRange should create the list [1, 2, ..., n]. What is the bug?","code":"PROCEDURE makeRange(n) {\n  range ← []\n  i ← 1\n  REPEAT UNTIL (i > n) {\n    APPEND(range, n)\n    i ← i + 1\n  }\n  RETURN(range)\n}\nresult ← makeRange(3)\nDISPLAY(result[1])","choices":["It appends n every time instead of i, so the list is [3, 3, 3]","The loop should go until i ≥ n instead of i > n","range must not be initialized as an empty list","The procedure should display range instead of returning it"],"correctIndex":0}
{"prompt":"Hard 26 (procedures + lists): sumFirst should return the sum of the first k elements. What is the off-by-one bug?","code":"PROCEDURE sumFirst(list, k) {\n  total ← 0\n  index ← 1\n  REPEAT UNTIL (index ≥ k) {\n    total ← total + list[index]\n    index ← index + 1\n  }\n  RETURN(total)\n}\nvalues ← [2, 4, 6]\nDISPLAY(sumFirst(values, 2))","choices":["It stops when index reaches k, so the element at position k is never added","index should start at 0 instead of 1","total must start at list[1] instead of 0","The loop should be REPEAT k TIMES rather than UNTIL"],"correctIndex":0}
{"prompt":"Hard 27 (procedures + lists): doubledCopy should create a new doubled list without changing original. Why is original changed?","code":"PROCEDURE doubledCopy(list) {\n  copy ← list\n  FOR EACH i IN copy {\n    i ← i * 2\n  }\n  RETURN(copy)\n}\nnums ← [1, 2]\nresult ← doubledCopy(nums)\nDISPLAY(nums[1])","choices":["copy and list refer to the same list, so changing copy also changes nums","The FOR EACH must use list, not copy","The procedure should modify list directly instead of using a copy","RETURN(copy) must appear before the FOR EACH loop"],"correctIndex":0}
{"prompt":"Hard 28 (procedures + lists): minValue should return the smallest element. What is the bug?","code":"PROCEDURE minValue(numbers) {\n  min ← numbers[1]\n  FOR EACH n IN numbers {\n    IF (n < min) {\n      min ← min\n    }\n  }\n  RETURN(min)\n}\nvalues ← [5, 2, 9]\nDISPLAY(minValue(values))","choices":["Inside the IF it assigns min to itself instead of assigning min to n","min must start at 0 for all lists","The comparison should be n > min to find the minimum","The procedure must RETURN numbers instead of min"],"correctIndex":0}
{"prompt":"Hard 29 (procedures + lists): concatStrings should join all parts into one string. Why is it wrong?","code":"PROCEDURE concatStrings(list) {\n  result ← \"\"\n  FOR EACH part IN list {\n    result ← part\n  }\n  RETURN(result)\n}\nwords ← [\"A\", \"B\", \"C\"]\nDISPLAY(concatStrings(words))","choices":["It replaces result each time instead of adding; it should be result ← result + part","The loop should stop after the first part","result must be a list, not a string","concatStrings must return list instead of the combined string"],"correctIndex":0}
{"prompt":"Hard 30 (procedures + lists): countAboveAverage should return how many items are greater than the average. What is the bug?","code":"PROCEDURE countAboveAverage(numbers) {\n  total ← 0\n  FOR EACH n IN numbers {\n    total ← total + n\n  }\n  avg ← total / LENGTH(numbers)\n  count ← 0\n  FOR EACH n IN numbers {\n    IF (n > avg) {\n      count ← count + 1\n    }\n  }\n  RETURN(total)\n}\nvalues ← [1, 2, 3]\nDISPLAY(countAboveAverage(values))","choices":["It returns total instead of count, so it never reports how many are above average","avg should divide by LENGTH(numbers) - 1","The second loop should use a different loop variable name","The procedure must display count and not return it"],"correctIndex":0}
{"prompt":"Hard 31 (procedures + lists): isSorted should return TRUE if list is in ascending order. Why is it wrong?","code":"PROCEDURE isSorted(list) {\n  index ← 1\n  REPEAT UNTIL (index > LENGTH(list)) {\n    IF (list[index] > list[index + 1]) {\n      RETURN(FALSE)\n    }\n    index ← index + 1\n  }\n  RETURN(TRUE)\n}\nvalues ← [1, 2, 3]\nDISPLAY(isSorted(values))","choices":["When index is at the last element, list[index + 1] is out of range","The comparison should use ≥ instead of >","The loop should go backwards from the end to the start","The procedure should RETURN(FALSE) after the loop instead of TRUE"],"correctIndex":0}
{"prompt":"Hard 32 (procedures + lists): doubledNew should return a new doubled list and leave original unchanged. Why does original change?","code":"PROCEDURE doubledNew(list) {\n  FOR EACH i IN list {\n    i ← i * 2\n  }\n  RETURN(list)\n}\nnums ← [1, 2]\nresult ← doubledNew(nums)\nDISPLAY(nums[1])","choices":["It modifies the original list directly instead of building a separate copy","The FOR EACH must not change its loop variable","RETURN(list) must be replaced with RETURN(result)","Lists with numbers cannot be returned from procedures"],"correctIndex":0}
{"prompt":"Hard 33 (procedures + lists): addFront should put value at the beginning of list and return it. What is the bug?","code":"PROCEDURE addFront(list, value) {\n  INSERT(list, LENGTH(list), value)\n  RETURN(list)\n}\nnums ← [2, 3]\nDISPLAY(addFront(nums, 1)[1])","choices":["It inserts value near the end instead of at index 1","INSERT should be replaced with APPEND for the first element","The procedure must not return list after INSERT","value must be removed before being inserted"],"correctIndex":0}
{"prompt":"Hard 34 (procedures + lists): clearList should remove all items, but some remain. Why?","code":"PROCEDURE clearList(list) {\n  index ← 1\n  REPEAT UNTIL (index > LENGTH(list)) {\n    REMOVE(list, index)\n    index ← index + 1\n  }\n}\nnums ← [1, 2, 3]\nclearList(nums)\nDISPLAY(LENGTH(nums))","choices":["Removing an element shifts later elements left, but index still increases, so some elements are skipped","The loop should use REPEAT LENGTH(list) TIMES and ignore changes","REMOVE should be called with the value, not the index","clearList must RETURN list to remove items"],"correctIndex":0}
{"prompt":"Hard 35 (procedures + lists): positives should return a list of positive numbers. Why may it crash?","code":"PROCEDURE positives(list) {\n  result ← []\n  index ← 1\n  REPEAT UNTIL (index > LENGTH(list)) {\n    IF (list[index] > 0) {\n      APPEND(result, list[index])\n    }\n    index ← index + 1\n  }\n  RETURN(result[1])\n}\nnums ← [-1, -2]\nDISPLAY(positives(nums))","choices":["If there are no positive numbers, result[1] does not exist in the returned list","result must start with one placeholder element","The IF should use list[index] ≥ 0 instead of > 0","APPEND must be outside the loop, not inside"],"correctIndex":0}
{"prompt":"Hard 36 (procedures + lists): middleElement should return the middle value for an odd-length list. What is the bug?","code":"PROCEDURE middleElement(list) {\n  index ← LENGTH(list) / 2\n  RETURN(list[index])\n}\nvalues ← [1, 3, 5]\nDISPLAY(middleElement(values))","choices":["For odd lengths, LENGTH(list) / 2 gives the lower index; it should be LENGTH(list) / 2 + 1","The procedure must loop to find the middle instead of using division","The middle element is always at index 1 in AP CSP lists","It should return LENGTH(list) instead of a list element"],"correctIndex":0}
{"prompt":"Hard 37 (procedures + lists): removeFirstMatch should remove the first occurrence of target. Why might it remove the wrong element?","code":"PROCEDURE removeFirstMatch(list, target) {\n  index ← 1\n  REPEAT UNTIL (index > LENGTH(list)) {\n    IF (list[index] = target) {\n      REMOVE(list, index + 1)\n      RETURN(TRUE)\n    }\n    index ← index + 1\n  }\n  RETURN(FALSE)\n}\nvals ← [4, 5, 5, 6]\nremoveFirstMatch(vals, 5)\nDISPLAY(vals)","choices":["It removes at index + 1 instead of index, so it deletes the element after the match","The procedure must return the updated list, not TRUE or FALSE","The loop should continue after removing instead of returning","target must be at the front of the list for this to work"],"correctIndex":0}
{"prompt":"Hard 38 (procedures + lists): firstTwo should return the first two elements in a new list. What is the bug?","code":"PROCEDURE firstTwo(list) {\n  result ← []\n  APPEND(result, list[1])\n  APPEND(result, list[1])\n  RETURN(result)\n}\nnums ← [9, 8, 7]\nDISPLAY(firstTwo(nums))","choices":["It appends list[1] twice instead of list[1] and list[2]","The result list should start as [0, 0]","APPEND must not be used twice in a row","The procedure should modify list directly instead of returning"],"correctIndex":0}
{"prompt":"Hard 39 (procedures + lists): sumEvenPositions should sum values at positions 2, 4, 6, and so on. Why is the sum wrong?","code":"PROCEDURE sumEvenPositions(list) {\n  total ← 0\n  index ← 1\n  REPEAT UNTIL (index > LENGTH(list)) {\n    IF (index MOD 2 = 0) {\n      total ← total + list[index]\n    }\n    index ← index + 2\n  }\n  RETURN(total)\n}\nvals ← [1, 2, 3, 4]\nDISPLAY(sumEvenPositions(vals))","choices":["index already skips by 2, so combining that with the MOD test can miss some even positions","The IF should test index MOD 2 ≠ 0","The loop should start with index ← 2 instead of 1","total should be reset each time inside the loop"],"correctIndex":0}
{"prompt":"Hard 40 (procedures + lists): copyWithoutFirst should return all elements except the first one. What is the bug?","code":"PROCEDURE copyWithoutFirst(list) {\n  result ← []\n  index ← 1\n  REPEAT UNTIL (index > LENGTH(list)) {\n    APPEND(result, list[index])\n    index ← index + 1\n  }\n  RETURN(result)\n}\nnums ← [5, 6, 7]\nDISPLAY(copyWithoutFirst(nums))","choices":["It copies every element, including the first one; it should start at index 2","result should be initialized with the first element instead of being empty","The loop should stop when index ≥ LENGTH(list)","APPEND must use index 1 each time"],"correctIndex":0}
{"prompt":"Hard 41 (procedures + lists): anyNegative should return TRUE if there is at least one negative value. Why is it incorrect?","code":"PROCEDURE anyNegative(list) {\n  FOR EACH val IN list {\n    IF (val < 0) {\n      RETURN(FALSE)\n    }\n  }\n  RETURN(TRUE)\n}\nnums ← [1, -2, 3]\nDISPLAY(anyNegative(nums))","choices":["It returns FALSE when it sees a negative, but the meaning of TRUE and FALSE is swapped","The IF should compare val to a Boolean instead of 0","The FOR EACH loop must be replaced with REPEAT UNTIL","It should only check the first element, not all of them"],"correctIndex":0}
{"prompt":"Hard 42 (procedures + lists): lastIndexOf should return the last index where target appears. What is the bug?","code":"PROCEDURE lastIndexOf(list, target) {\n  index ← 1\n  last ← 0\n  REPEAT UNTIL (index > LENGTH(list)) {\n    IF (list[index] = target) {\n      last ← index\n      RETURN(last)\n    }\n    index ← index + 1\n  }\n  RETURN(last)\n}\nvals ← [2, 3, 2, 4]\nDISPLAY(lastIndexOf(vals, 2))","choices":["It returns as soon as it finds the first match, so later matches are never considered","last should start at 1 instead of 0","The loop should run backwards from the end","It should use INSERT instead of RETURN for last"],"correctIndex":0}
{"prompt":"Hard 43 (procedures + lists): mergeLengths should return a list [LENGTH(a), LENGTH(b)]. Why is the result wrong?","code":"PROCEDURE mergeLengths(a, b) {\n  result ← []\n  APPEND(result, LENGTH(a))\n  APPEND(result, LENGTH(a))\n  RETURN(result)\n}\nx ← [1]\ny ← [2, 3]\nDISPLAY(mergeLengths(x, y))","choices":["It appends LENGTH(a) twice instead of LENGTH(a) and LENGTH(b)","It should append lists a and b, not their lengths","result should start with two placeholder values","The procedure must RETURN a and b, not result"],"correctIndex":0}
{"prompt":"Hard 44 (procedures + lists): prefixSum should return a list where each element is the sum up to that position. What is the bug?","code":"PROCEDURE prefixSum(list) {\n  sums ← []\n  running ← 0\n  FOR EACH value IN list {\n    running ← running + value\n  }\n  RETURN(sums)\n}\nnums ← [1, 2, 3]\nDISPLAY(prefixSum(nums))","choices":["It never appends running into sums, so sums stays empty","running should be declared inside the loop","FOR EACH cannot be used with running totals","The procedure should return running instead of sums"],"correctIndex":0}
{"prompt":"Hard 45 (procedures + lists): getFirstOddIndex should return the index of the first odd value or 0 if none. What is the bug?","code":"PROCEDURE getFirstOddIndex(list) {\n  index ← 1\n  REPEAT UNTIL (index > LENGTH(list)) {\n    IF (list[index] MOD 2 = 1) {\n      RETURN(TRUE)\n    }\n    index ← index + 1\n  }\n  RETURN(0)\n}\nvalues ← [2, 4, 5]\nDISPLAY(getFirstOddIndex(values))","choices":["It returns TRUE instead of the index when it finds an odd value","The IF must use list[index] MOD 2 = 0","The final RETURN(0) should be inside the loop","index should start at 0 instead of 1"],"correctIndex":0}
{"prompt":"Hard 46 (procedures + lists): removeAllTarget should remove every occurrence of target. Why does it miss some?","code":"PROCEDURE removeAllTarget(list, target) {\n  index ← 1\n  REPEAT UNTIL (index > LENGTH(list)) {\n    IF (list[index] = target) {\n      REMOVE(list, index)\n      index ← index + 1\n    }\n    index ← index + 1\n  }\n}\nvals ← [1, 2, 2, 3]\nremoveAllTarget(vals, 2)\nDISPLAY(vals)","choices":["After a removal, elements shift left but index is still increased twice, so some matches are skipped","The IF should use list[index] ≠ target","REMOVE must be called with target, not index","The loop should stop after the first removal"],"correctIndex":0}
{"prompt":"Hard 47 (procedures + lists): countUnique should count how many different values are in the list. Why is this approach wrong?","code":"PROCEDURE countUnique(list) {\n  RETURN(LENGTH(list))\n}\nvals ← [1, 1, 2]\nDISPLAY(countUnique(vals))","choices":["It just returns the list length and never checks for duplicates","It should return 0 for any list with repeated values","countUnique must sort the list before returning","LENGTH cannot be used for lists that contain duplicates"],"correctIndex":0}
{"prompt":"Hard 48 (procedures + lists): firstNonZero should return the first nonzero value. Why might this crash?","code":"PROCEDURE firstNonZero(list) {\n  index ← 1\n  REPEAT UNTIL (list[index] ≠ 0) {\n    index ← index + 1\n  }\n  RETURN(list[index])\n}\nvals ← [0, 0, 0]\nDISPLAY(firstNonZero(vals))","choices":["If all values are zero, index will move past the end of the list and list[index] is invalid","The loop should use REPEAT UNTIL (index > LENGTH(list))","It must return index instead of list[index]","Nonzero values cannot be stored in lists"],"correctIndex":0}
{"prompt":"Hard 49 (procedures + lists): findLast should return the last element greater than limit. What is the bug?","code":"PROCEDURE findLast(list, limit) {\n  last ← -1\n  FOR EACH value IN list {\n    IF (value > limit) {\n      last ← value\n      RETURN(last)\n    }\n  }\n  RETURN(last)\n}\nvals ← [3, 7, 5]\nDISPLAY(findLast(vals, 4))","choices":["It returns as soon as it finds the first match instead of the last match","last should store the index, not the value","The IF must use value ≥ limit","The RETURN(last) after the loop should be removed"],"correctIndex":0}
{"prompt":"Hard 50 (procedures + lists): sumExceptFirst should sum all values except the first. Why is the sum off by one element?","code":"PROCEDURE sumExceptFirst(list) {\n  total ← 0\n  index ← 1\n  REPEAT UNTIL (index > LENGTH(list)) {\n    total ← total + list[index]\n    index ← index + 1\n  }\n  RETURN(total)\n}\nvals ← [5, 1, 2]\nDISPLAY(sumExceptFirst(vals))","choices":["It starts adding at index 1, so it includes the first element instead of skipping it","The loop should stop at index ≥ LENGTH(list)","total should start at list[1]","It must subtract the first element at the end instead of skipping it"],"correctIndex":0}
{"prompt":"Hard 51 (procedures + lists): getOdds should collect all odd values into a new list. Why is original list changed?","code":"PROCEDURE getOdds(list) {\n  odds ← list\n  index ← 1\n  REPEAT UNTIL (index > LENGTH(odds)) {\n    IF (odds[index] MOD 2 = 0) {\n      REMOVE(odds, index)\n    }\n    ELSE {\n      index ← index + 1\n    }\n  }\n  RETURN(odds)\n}\nnums ← [1, 2, 3]\nresult ← getOdds(nums)\nDISPLAY(nums)","choices":["odds and list refer to the same list, so removals also affect nums","The IF should remove odd values instead of even ones","The ELSE block should not update index","getOdds must rebuild odds using APPEND instead of REMOVE"],"correctIndex":0}
{"prompt":"Hard 52 (procedures + lists): copyHead should copy the first k elements into a new list. Why is the new list too long?","code":"PROCEDURE copyHead(list, k) {\n  result ← []\n  index ← 1\n  REPEAT UNTIL (index > LENGTH(list)) {\n    APPEND(result, list[index])\n    index ← index + 1\n  }\n  RETURN(result)\n}\nvals ← [4, 5, 6]\nDISPLAY(copyHead(vals, 2))","choices":["It ignores k and copies the entire list instead of only the first k elements","The loop should start with index ← 0","APPEND should stop after two elements","The procedure should return list instead of result"],"correctIndex":0}
{"prompt":"Hard 53 (procedures + lists): sum2DRow should sum the values in a particular row of a 2D list. What is the bug?","code":"PROCEDURE sum2DRow(grid, row) {\n  total ← 0\n  col ← 1\n  REPEAT UNTIL (col > LENGTH(grid)) {\n    total ← total + grid[row][col]\n    col ← col + 1\n  }\n  RETURN(total)\n}\nnums ← [[1, 2], [3, 4]]\nDISPLAY(sum2DRow(nums, 1))","choices":["It uses LENGTH(grid) for columns instead of the length of grid[row]","row should always be 1 for the first row","The inner indexing grid[row][col] is invalid in AP CSP pseudocode","total must start at grid[row][1]"],"correctIndex":0}
{"prompt":"Hard 54 (procedures + lists): flatten2 should merge two lists into one. Why is one list missing?","code":"PROCEDURE flatten2(a, b) {\n  result ← []\n  FOR EACH x IN a {\n    APPEND(result, x)\n  }\n  RETURN(result)\n}\nvalsA ← [1, 2]\nvalsB ← [3, 4]\nDISPLAY(flatten2(valsA, valsB))","choices":["It never processes list b, so only elements from a appear in result","result must be initialized with a and then b appended","FOR EACH cannot iterate over numeric lists","The procedure must return both a and b instead of result"],"correctIndex":0}
{"prompt":"Hard 55 (procedures + lists): prependZero should add a zero to the front of list and return it. What is the bug?","code":"PROCEDURE prependZero(list) {\n  APPEND(list, 0)\n  RETURN(list)\n}\nnums ← [5, 6]\nDISPLAY(prependZero(nums)[1])","choices":["It appends 0 at the end instead of inserting it at the front","The procedure should not return the list after modification","0 cannot be stored in AP CSP lists","nums must be empty for prependZero to work"],"correctIndex":0}
{"prompt":"Hard 56 (procedures + lists): maxIndex should return the index of the largest element. Why is it wrong?","code":"PROCEDURE maxIndex(list) {\n  index ← 1\n  maxPos ← 1\n  maxVal ← list[1]\n  REPEAT UNTIL (index > LENGTH(list)) {\n    IF (list[index] > maxVal) {\n      maxVal ← list[index]\n    }\n    index ← index + 1\n  }\n  RETURN(index)\n}\nvals ← [2, 9, 4]\nDISPLAY(maxIndex(vals))","choices":["It returns index after the loop instead of maxPos, so it never reports the correct position","maxVal should not be updated inside the loop","maxPos must start at 0","The IF should compare index to maxVal"],"correctIndex":0}
{"prompt":"Hard 57 (procedures + lists): removeLast should delete the last element of list. Why does it remove the wrong one?","code":"PROCEDURE removeLast(list) {\n  REMOVE(list, LENGTH(list) - 1)\n}\nvals ← [7, 8, 9]\nremoveLast(vals)\nDISPLAY(vals)","choices":["It removes at LENGTH(list) - 1, which is the second to last element","REMOVE cannot use LENGTH(list) as its index","The procedure must return list for the removal to apply","The last element is always at index 1 in AP CSP lists"],"correctIndex":0}
{"prompt":"Hard 58 (procedures + lists): copyWithoutTarget should copy all elements except the target value. Why does target still appear?","code":"PROCEDURE copyWithoutTarget(list, target) {\n  result ← []\n  FOR EACH val IN list {\n    IF (val = target) {\n      APPEND(result, val)\n    }\n  }\n  RETURN(result)\n}\nvals ← [1, 2, 2, 3]\nDISPLAY(copyWithoutTarget(vals, 2))","choices":["The IF adds val when it equals target, instead of when it does not equal target","result should be initialized with a copy of list","The FOR EACH should use index instead of val","The procedure must modify list instead of returning result"],"correctIndex":0}
{"prompt":"Hard 59 (procedures + lists): allEqual should return TRUE if every value equals the first value. Why is it incorrect?","code":"PROCEDURE allEqual(list) {\n  first ← list[1]\n  FOR EACH val IN list {\n    IF (val = first) {\n      RETURN(TRUE)\n    }\n  }\n  RETURN(FALSE)\n}\nvals ← [5, 5, 6]\nDISPLAY(allEqual(vals))","choices":["It returns TRUE as soon as any element matches first, instead of checking them all","first should be the last element instead of the first","The procedure should loop from index 2 only","It must return a list of matches instead of a Boolean"],"correctIndex":0}
{"prompt":"Hard 60 (procedures + lists): averagePositive should return the average of the positive numbers only. What is the bug?","code":"PROCEDURE averagePositive(list) {\n  total ← 0\n  count ← 0\n  FOR EACH val IN list {\n    IF (val > 0) {\n      total ← total + val\n    }\n  }\n  RETURN(total / count)\n}\nvals ← [1, -2, 3]\nDISPLAY(averagePositive(vals))","choices":["count is never incremented, so dividing by count is invalid","The IF should use val ≥ 0 instead of val > 0","total should start at 1","It should return count instead of total / count"],"correctIndex":0}
{"prompt":"Hard 61 (procedures + lists): copyEveryOther should copy elements at positions 1, 3, 5, and so on. Why is it wrong?","code":"PROCEDURE copyEveryOther(list) {\n  result ← []\n  index ← 2\n  REPEAT UNTIL (index > LENGTH(list)) {\n    APPEND(result, list[index])\n    index ← index + 2\n  }\n  RETURN(result)\n}\nvals ← [10, 20, 30, 40]\nDISPLAY(copyEveryOther(vals))","choices":["It starts at index 2, so it copies positions 2 and 4 instead of 1 and 3","index should be incremented by 1","APPEND must also include the index value","result cannot be returned from a procedure"],"correctIndex":0}
{"prompt":"Hard 62 (procedures + lists): findMinIndex should return the index of the smallest element. Why is it wrong?","code":"PROCEDURE findMinIndex(list) {\n  minIndex ← 1\n  minValue ← list[1]\n  index ← 1\n  REPEAT UNTIL (index > LENGTH(list)) {\n    IF (list[index] < minValue) {\n      minValue ← list[index]\n    }\n    index ← index + 1\n  }\n  RETURN(minIndex)\n}\nvals ← [5, 2, 9]\nDISPLAY(findMinIndex(vals))","choices":["minIndex is never updated when a smaller value is found","minValue should start at 0","The loop should start at index 2 instead of 1","The procedure must return minValue instead of minIndex"],"correctIndex":0}
{"prompt":"Hard 63 (procedures + lists): removeAllAbove removes all values above a limit. Why might it skip removals?","code":"PROCEDURE removeAllAbove(list, limit) {\n  index ← 1\n  REPEAT UNTIL (index > LENGTH(list)) {\n    IF (list[index] > limit) {\n      REMOVE(list, index)\n    }\n    ELSE {\n      index ← index + 1\n    }\n  }\n}\nvals ← [3, 10, 12, 4]\nremoveAllAbove(vals, 5)\nDISPLAY(vals)","choices":["When a removal happens, index is not increased, so if two large values are in a row only the first is removed each time through the loop","The IF should use list[index] ≥ limit","limit should always be positive","The procedure must RETURN list for changes to apply"],"correctIndex":0}
{"prompt":"Hard 64 (procedures + lists): getSecondOrDefault should return the second element, or -1 if it does not exist. Why does it sometimes crash?","code":"PROCEDURE getSecondOrDefault(list) {\n  IF (LENGTH(list) < 2) {\n    RETURN(-1)\n  }\n  RETURN(list[3])\n}\nvals ← [9]\nDISPLAY(getSecondOrDefault(vals))","choices":["It returns list[3] for nonempty lists, but the second element is at index 2","The check should be LENGTH(list) ≤ 2 instead of < 2","It must return list[1] for single-element lists","-1 cannot be used as a default"],"correctIndex":0}
{"prompt":"Hard 65 (procedures + lists): removeAt should remove the element at a given index. Why is it off by one?","code":"PROCEDURE removeAt(list, index) {\n  REMOVE(list, index + 1)\n}\nvals ← [4, 5, 6]\nremoveAt(vals, 2)\nDISPLAY(vals)","choices":["It removes at index + 1, so it deletes the element after the requested one","REMOVE must use the value, not the index","index should be ignored and always remove the last element","Lists must start at index 0 rather than 1"],"correctIndex":0}
{"prompt":"Hard 66 (procedures + lists): replaceAll should replace each occurrence of target with newValue. Why is only one replaced?","code":"PROCEDURE replaceAll(list, target, newValue) {\n  index ← 1\n  REPEAT UNTIL (index > LENGTH(list)) {\n    IF (list[index] = target) {\n      list[index] ← newValue\n      RETURN(TRUE)\n    }\n    index ← index + 1\n  }\n  RETURN(FALSE)\n}\nvals ← [1, 2, 2, 3]\nreplaceAll(vals, 2, 9)\nDISPLAY(vals)","choices":["The procedure returns as soon as it replaces the first match, so other matches are never changed","It should use APPEND instead of assignment when replacing","newValue must be placed at index 1 only","The loop should run backwards from the end"],"correctIndex":0}
{"prompt":"Hard 67 (procedures + lists): sumTail should sum all elements after the first one. Why is the result 0 for a single-element list?","code":"PROCEDURE sumTail(list) {\n  total ← 0\n  index ← 2\n  REPEAT UNTIL (index > LENGTH(list)) {\n    total ← total + list[index]\n    index ← index + 1\n  }\n  RETURN(total)\n}\nvals ← [5]\nDISPLAY(sumTail(vals))","choices":["For a single-element list, the loop never runs, so total correctly stays 0 but the design might expect a different default","The index should start at 1 instead of 2","total should start at list[1]","The procedure must return list instead of total"],"correctIndex":0}
{"prompt":"Hard 68 (procedures + lists): appendAverage should append the average of the list to the end. Why is the average always 0?","code":"PROCEDURE appendAverage(list) {\n  total ← 0\n  count ← 0\n  FOR EACH val IN list {\n    count ← count + 1\n  }\n  APPEND(list, total / count)\n}\nvals ← [2, 4, 6]\nappendAverage(vals)\nDISPLAY(vals)","choices":["total is never updated, so total / count is always 0","count should start at 0 outside the procedure","The average should be inserted at the front, not appended","FOR EACH cannot be used to count elements"],"correctIndex":0}
{"prompt":"Hard 69 (procedures + lists): makePairList should return [a, b] but also leave the original a and b unchanged. What is the bug?","code":"PROCEDURE makePairList(a, b) {\n  a ← [a]\n  APPEND(a, b)\n  RETURN(a)\n}\nx ← 1\ny ← 2\nresult ← makePairList(x, y)\nDISPLAY(x)","choices":["It reassigns a to a list, which hides the original value but does not affect x; the design mixes names in a confusing way","It should modify x and y directly instead of making a list","The APPEND must use y as a list, not as a value","The procedure should return b instead of a"],"correctIndex":0}
{"prompt":"Hard 70 (procedures + lists): truncateToLength should keep only the first n elements of list in place. Why does it do nothing when list is longer?","code":"PROCEDURE truncateToLength(list, n) {\n  index ← LENGTH(list)\n  REPEAT UNTIL (index > n) {\n    index ← index - 1\n  }\n}\nvals ← [1, 2, 3, 4]\ntruncateToLength(vals, 2)\nDISPLAY(vals)","choices":["It never removes any elements; it just changes index without calling REMOVE","It should append elements instead of truncating them","The loop should start at index ← 1","n must be greater than LENGTH(list)"],"correctIndex":0}
{"prompt":"Hard 71 (procedures + lists): removeOdds should remove all odd numbers. Why does it never remove the first element when it is odd?","code":"PROCEDURE removeOdds(list) {\n  index ← 2\n  REPEAT UNTIL (index > LENGTH(list)) {\n    IF (list[index] MOD 2 = 1) {\n      REMOVE(list, index)\n    }\n    ELSE {\n      index ← index + 1\n    }\n  }\n}\nvals ← [3, 5, 6]\nremoveOdds(vals)\nDISPLAY(vals)","choices":["It starts at index 2, so it never checks the first element","The IF should check for even values instead","REMOVE must use the value instead of the index","index should be reset to 1 after each removal"],"correctIndex":0}
{"prompt":"Hard 72 (procedures + lists): firstIndexGreaterThan should return the first index with a value greater than limit. Why might it always return 0?","code":"PROCEDURE firstIndexGreaterThan(list, limit) {\n  index ← 1\n  REPEAT UNTIL (index > LENGTH(list)) {\n    IF (list[index] > limit) {\n      RETURN(index)\n    }\n    index ← index + 1\n  }\n  RETURN(0)\n}\nvals ← []\nDISPLAY(firstIndexGreaterThan(vals, 10))","choices":["On an empty list it immediately returns 0, which might be indistinguishable from a valid list index scheme that starts at 0","limit should be inside the list","The IF must use list[index] ≥ limit","The procedure should return list instead of an index"],"correctIndex":0}
{"prompt":"Hard 73 (procedures + lists): sumEveryThird should sum values at positions 1, 4, 7, and so on. Why is it wrong?","code":"PROCEDURE sumEveryThird(list) {\n  total ← 0\n  index ← 3\n  REPEAT UNTIL (index > LENGTH(list)) {\n    total ← total + list[index]\n    index ← index + 3\n  }\n  RETURN(total)\n}\nvals ← [2, 4, 6, 8]\nDISPLAY(sumEveryThird(vals))","choices":["It starts at index 3, so it sums positions 3, 6, and so on instead of 1, 4, 7","index should be incremented by 1","total must start at list[1]","The loop should use FOR EACH with MOD instead"],"correctIndex":0}
{"prompt":"Hard 74 (procedures + lists): rotateLeft should move the first element to the end. Why does it lose the first element?","code":"PROCEDURE rotateLeft(list) {\n  REMOVE(list, 1)\n  APPEND(list, list[1])\n}\nvals ← [9, 8, 7]\nrotateLeft(vals)\nDISPLAY(vals)","choices":["It appends the new first element instead of the removed one, so the original first value is lost","It should remove the last element instead of the first","APPEND must happen before REMOVE","rotateLeft must RETURN list for changes to apply"],"correctIndex":0}
{"prompt":"Hard 75 (procedures + lists): copyWithoutEdges should copy all elements except the first and last. Why does it sometimes crash?","code":"PROCEDURE copyWithoutEdges(list) {\n  result ← []\n  index ← 2\n  REPEAT UNTIL (index > LENGTH(list) - 1) {\n    APPEND(result, list[index])\n    index ← index + 1\n  }\n  RETURN(result)\n}\nvals ← [5]\nDISPLAY(copyWithoutEdges(vals))","choices":["When the list has fewer than 3 elements, the bounds make the indexes invalid or the loop meaningless","index should start at 1","It should use REPEAT UNTIL (index ≥ LENGTH(list))","result must be initialized with placeholders"],"correctIndex":0}
{"prompt":"Hard 76 (procedures + lists): findFirstNonEmpty should find the first non-empty string. Why might it never terminate?","code":"PROCEDURE findFirstNonEmpty(list) {\n  index ← 1\n  REPEAT UNTIL (list[index] ≠ \"\") {\n  }\n  RETURN(list[index])\n}\nvals ← [\"\", \"\", \"A\"]\nDISPLAY(findFirstNonEmpty(vals))","choices":["The loop body never updates index, so the condition is never rechecked with a new value","The condition should use = instead of ≠","The procedure must RETURN index instead of list[index]","Empty strings cannot be stored in lists"],"correctIndex":0}
{"prompt":"Hard 77 (procedures + lists): dropFirstK should remove the first k elements. Why does it remove too many?","code":"PROCEDURE dropFirstK(list, k) {\n  index ← 1\n  REPEAT UNTIL (index > k) {\n    REMOVE(list, index)\n    index ← index + 1\n  }\n}\nvals ← [1, 2, 3, 4]\ndropFirstK(vals, 2)\nDISPLAY(vals)","choices":["After each removal, elements shift left, but index keeps increasing, so fewer than k are removed correctly; later removals may skip elements","It should always remove from the end instead","The loop should count down from k to 1","REMOVE must be called with k, not index"],"correctIndex":0}
{"prompt":"Hard 78 (procedures + lists): keepOnlyFirstMatch should keep only the first occurrence of target and remove later ones. Why does it remove the first instead?","code":"PROCEDURE keepOnlyFirstMatch(list, target) {\n  found ← FALSE\n  index ← 1\n  REPEAT UNTIL (index > LENGTH(list)) {\n    IF (list[index] = target AND found = FALSE) {\n      REMOVE(list, index)\n      found ← TRUE\n    }\n    ELSE IF (list[index] = target) {\n      index ← index + 1\n    }\n    ELSE {\n      index ← index + 1\n    }\n  }\n}\nvals ← [2, 3, 3, 4]\nkeepOnlyFirstMatch(vals, 3)\nDISPLAY(vals)","choices":["It removes the first time target is seen instead of keeping it, so the logic is reversed","found should start as TRUE","The ELSE IF should remove later copies, not the first","The loop must stop after the first removal"],"correctIndex":0}
{"prompt":"Hard 79 (procedures + lists): makeZerosCopy should create a new list of zeros the same length as list. Why is the length wrong?","code":"PROCEDURE makeZerosCopy(list) {\n  zeros ← []\n  index ← 1\n  REPEAT UNTIL (index > LENGTH(zeros)) {\n    APPEND(zeros, 0)\n    index ← index + 1\n  }\n  RETURN(zeros)\n}\nvals ← [1, 2, 3]\nDISPLAY(LENGTH(makeZerosCopy(vals)))","choices":["It uses LENGTH(zeros) in the loop condition, which starts at 0, so the loop body never runs","The loop should append the length of list, not zeros","zeros should start with one element already","It must MODIFY list instead of creating zeros"],"correctIndex":0}
{"prompt":"Hard 80 (procedures + lists): sumExceptLast should sum all elements except the last. Why is the last still included?","code":"PROCEDURE sumExceptLast(list) {\n  total ← 0\n  index ← 1\n  REPEAT UNTIL (index > LENGTH(list)) {\n    total ← total + list[index]\n    index ← index + 1\n  }\n  RETURN(total)\n}\nvals ← [2, 4, 6]\nDISPLAY(sumExceptLast(vals))","choices":["The loop runs through LENGTH(list), so it adds the last element as well","It should subtract the last element after the loop instead","index should start at 0","total should start at list[1]"],"correctIndex":0}
{"prompt":"Hard 81 (procedures + lists): countInRange should count values between low and high inclusive. Why does it miss values equal to the bounds?","code":"PROCEDURE countInRange(list, low, high) {\n  count ← 0\n  FOR EACH val IN list {\n    IF (val > low AND val < high) {\n      count ← count + 1\n    }\n  }\n  RETURN(count)\n}\nvals ← [1, 5, 10]\nDISPLAY(countInRange(vals, 1, 10))","choices":["It uses strict comparisons, so values equal to low or high are not counted","The condition should use OR instead of AND","count should be reset to 0 after the loop","The procedure must return list instead of count"],"correctIndex":0}
{"prompt":"Hard 82 (procedures + lists): getAllButLast should return all elements except the last. Why is the list one element too short?","code":"PROCEDURE getAllButLast(list) {\n  result ← []\n  index ← 1\n  REPEAT UNTIL (index ≥ LENGTH(list)) {\n    APPEND(result, list[index])\n    index ← index + 1\n  }\n  RETURN(result)\n}\nvals ← [3, 4, 5]\nDISPLAY(getAllButLast(vals))","choices":["The loop stops when index reaches LENGTH(list), so it never copies the element at that last index","It should start index at 0 instead","It should append list[LENGTH(list)] to result at the end","REPEAT UNTIL must use > instead of ≥"],"correctIndex":0}
{"prompt":"Hard 83 (procedures + lists): sumPairs should sum adjacent pairs into a new list. Why does it go out of bounds?","code":"PROCEDURE sumPairs(list) {\n  result ← []\n  index ← 1\n  REPEAT UNTIL (index > LENGTH(list)) {\n    APPEND(result, list[index] + list[index + 1])\n    index ← index + 2\n  }\n  RETURN(result)\n}\nvals ← [1, 2, 3]\nDISPLAY(sumPairs(vals))","choices":["When index reaches the last element, list[index + 1] is out of range for odd-length lists","index should always increase by 1","APPEND must not use arithmetic on list elements","result must contain the original list as well"],"correctIndex":0}
{"prompt":"Hard 84 (procedures + lists): maxOfThree should return the maximum of a three-element list. Why might it return the wrong value?","code":"PROCEDURE maxOfThree(list) {\n  max ← list[1]\n  IF (list[2] > max) {\n    max ← list[2]\n  }\n  ELSE IF (list[3] > max) {\n    max ← list[3]\n  }\n  RETURN(max)\n}\nvals ← [1, 3, 5]\nDISPLAY(maxOfThree(vals))","choices":["If list[2] is greater than max, the ELSE IF for list[3] is never checked","It should compare list[3] first","max should start at 0 instead of list[1]","The list must be sorted before calling maxOfThree"],"correctIndex":0}
{"prompt":"Hard 85 (procedures + lists): copyIfPositive should return only positive values. Why does it sometimes include negative ones?","code":"PROCEDURE copyIfPositive(list) {\n  result ← []\n  FOR EACH val IN list {\n    IF (val > 0) {\n      APPEND(result, val)\n    }\n    ELSE {\n      APPEND(result, val)\n    }\n  }\n  RETURN(result)\n}\nvals ← [-1, 2]\nDISPLAY(copyIfPositive(vals))","choices":["The ELSE also appends val, so every element is copied regardless of sign","The IF should use val ≥ 0","result must be cleared inside the loop","FOR EACH cannot have an ELSE branch"],"correctIndex":0}
{"prompt":"Hard 86 (procedures + lists): lastTwo should return the last two elements. Why does it sometimes crash on short lists?","code":"PROCEDURE lastTwo(list) {\n  n ← LENGTH(list)\n  result ← []\n  APPEND(result, list[n - 1])\n  APPEND(result, list[n])\n  RETURN(result)\n}\nvals ← [9]\nDISPLAY(lastTwo(vals))","choices":["When n is 1, n - 1 is 0, which is an invalid index in AP CSP lists","It must handle the case where list has only one element by returning it twice","result should be initialized with two zeros","The APPEND calls should use n and n + 1"],"correctIndex":0}
{"prompt":"Hard 87 (procedures + lists): replaceFirst should replace only the first occurrence of target. Why does it replace all of them?","code":"PROCEDURE replaceFirst(list, target, newVal) {\n  index ← 1\n  REPEAT UNTIL (index > LENGTH(list)) {\n    IF (list[index] = target) {\n      list[index] ← newVal\n    }\n    index ← index + 1\n  }\n}\nvals ← [2, 2, 2]\nreplaceFirst(vals, 2, 9)\nDISPLAY(vals)","choices":["It never stops after the first replacement, so all matches get changed","The IF should use list[index] ≠ target","newVal should be appended instead of assigned","The loop should start at index 2"],"correctIndex":0}
{"prompt":"Hard 88 (procedures + lists): sumOddIndices should sum values at odd indices 1, 3, 5, and so on. Why does it sum the wrong ones?","code":"PROCEDURE sumOddIndices(list) {\n  total ← 0\n  index ← 2\n  REPEAT UNTIL (index > LENGTH(list)) {\n    total ← total + list[index]\n    index ← index + 2\n  }\n  RETURN(total)\n}\nvals ← [1, 2, 3, 4]\nDISPLAY(sumOddIndices(vals))","choices":["It starts at index 2, so it sums even indices instead of odd ones","The index should decrease by 2","total must start at list[1]","The loop should use FOR EACH instead of a numeric index"],"correctIndex":0}
{"prompt":"Hard 89 (procedures + lists): copyPrefixWhilePositive should copy values from the start until the first nonpositive. Why does it copy too many?","code":"PROCEDURE copyPrefixWhilePositive(list) {\n  result ← []\n  index ← 1\n  REPEAT UNTIL (index > LENGTH(list)) {\n    APPEND(result, list[index])\n    IF (list[index] ≤ 0) {\n      RETURN(result)\n    }\n    index ← index + 1\n  }\n  RETURN(result)\n}\nvals ← [1, 2, -1, 3]\nDISPLAY(copyPrefixWhilePositive(vals))","choices":["It appends the nonpositive value before checking the condition, so that value is included","The IF should check list[index] ≥ 0","The RETURN should be after the loop instead of inside it","result should be cleared when a nonpositive is found"],"correctIndex":0}
{"prompt":"Hard 90 (procedures + lists): countZerosAfterFirst should count zeros after the first element. Why does it count zeros at the start too?","code":"PROCEDURE countZerosAfterFirst(list) {\n  count ← 0\n  index ← 1\n  REPEAT UNTIL (index > LENGTH(list)) {\n    IF (list[index] = 0) {\n      count ← count + 1\n    }\n    index ← index + 1\n  }\n  RETURN(count)\n}\nvals ← [0, 0, 1]\nDISPLAY(countZerosAfterFirst(vals))","choices":["It starts counting at index 1, so it includes zeros in the first position as well","count should start at list[1]","The IF must use list[index] ≠ 0","The loop should stop at index ≥ LENGTH(list)"],"correctIndex":0}
{"prompt":"Hard 91 (procedures + lists): sumExceptFirstAndLast should sum all but the first and last elements. Why does it sometimes return 0 even when there are middle elements?","code":"PROCEDURE sumExceptFirstAndLast(list) {\n  total ← 0\n  index ← 2\n  REPEAT UNTIL (index > LENGTH(list) - 1) {\n    total ← total + list[index]\n    index ← index + 1\n  }\n  RETURN(total)\n}\nvals ← [1, 2, 3]\nDISPLAY(sumExceptFirstAndLast(vals))","choices":["When the list has exactly two elements, there are no valid middle indices to add, so total stays 0","The loop should start at index 1","The condition should be index ≥ LENGTH(list)","total must start at list[2]"],"correctIndex":0}
{"prompt":"Hard 92 (procedures + lists): firstIndexOfZero should return the index of the first zero or 0 if none. Why can it crash?","code":"PROCEDURE firstIndexOfZero(list) {\n  index ← 1\n  REPEAT UNTIL (list[index] = 0 OR index > LENGTH(list)) {\n    index ← index + 1\n  }\n  IF (index > LENGTH(list)) {\n    RETURN(0)\n  }\n  RETURN(index)\n}\nvals ← []\nDISPLAY(firstIndexOfZero(vals))","choices":["The UNTIL condition checks list[index] before ensuring index is in range, which can fail for empty lists","The OR should be AND in the UNTIL condition","The check index > LENGTH(list) should be removed","It must return list instead of index"],"correctIndex":0}
{"prompt":"Hard 93 (procedures + lists): copyUntilTarget should copy values up to but not including target. Why is target included?","code":"PROCEDURE copyUntilTarget(list, target) {\n  result ← []\n  index ← 1\n  REPEAT UNTIL (index > LENGTH(list) OR list[index] = target) {\n    APPEND(result, list[index])\n    index ← index + 1\n  }\n  IF (index ≤ LENGTH(list)) {\n    APPEND(result, list[index])\n  }\n  RETURN(result)\n}\nvals ← [1, 2, 3, 4]\nDISPLAY(copyUntilTarget(vals, 3))","choices":["After the loop, it appends list[index], which is target, even though the design says to stop before it","The UNTIL condition should use AND instead of OR","The loop should start at index 0","target must be removed from list first"],"correctIndex":0}
{"prompt":"Hard 94 (procedures + lists): sumWithDefault should sum the list, but treat an empty list as having sum 0. Why might this return an error instead?","code":"PROCEDURE sumWithDefault(list) {\n  total ← 0\n  index ← 1\n  REPEAT UNTIL (index > LENGTH(list)) {\n    total ← total + list[index]\n    index ← index + 1\n  }\n  RETURN(list[1] + total)\n}\nvals ← []\nDISPLAY(sumWithDefault(vals))","choices":["For an empty list, list[1] is invalid, so the final RETURN expression fails","total should be divided by LENGTH(list)","The loop should run at least once for empty lists","index must start at 0"],"correctIndex":0}
{"prompt":"Hard 95 (procedures + lists): filterNonZero should remove zeros in place. Why does it sometimes skip consecutive zeros?","code":"PROCEDURE filterNonZero(list) {\n  index ← 1\n  REPEAT UNTIL (index > LENGTH(list)) {\n    IF (list[index] = 0) {\n      REMOVE(list, index)\n      index ← index + 1\n    }\n    ELSE {\n      index ← index + 1\n    }\n  }\n}\nvals ← [0, 0, 1]\nfilterNonZero(vals)\nDISPLAY(vals)","choices":["After removal, the next value shifts into the same index, but index is still increased, so back-to-back zeros are skipped","The IF should check list[index] ≠ 0","REMOVE must be called with 0 instead of index","The loop should count down from the end"],"correctIndex":0}
{"prompt":"Hard 96 (procedures + lists): replaceAllWithIndex should replace each element with its index. Why does it not change the list?","code":"PROCEDURE replaceAllWithIndex(list) {\n  index ← 1\n  FOR EACH val IN list {\n    val ← index\n    index ← index + 1\n  }\n}\nvals ← [7, 8, 9]\nreplaceAllWithIndex(vals)\nDISPLAY(vals)","choices":["Assigning to val does not update the corresponding element in list","index should start at 0 instead of 1","The FOR EACH loop must not have its own index","It must RETURN list for changes to apply"],"correctIndex":0}
{"prompt":"Hard 97 (procedures + lists): zipSum should return a new list where each element is the sum of elements from a and b at the same index. Why can it crash if the lists are different lengths?","code":"PROCEDURE zipSum(a, b) {\n  result ← []\n  index ← 1\n  REPEAT UNTIL (index > LENGTH(a)) {\n    APPEND(result, a[index] + b[index])\n    index ← index + 1\n  }\n  RETURN(result)\n}\nvalsA ← [1, 2, 3]\nvalsB ← [4, 5]\nDISPLAY(zipSum(valsA, valsB))","choices":["It assumes b has at least as many elements as a, so b[index] can be out of range","It should sum all of a first and then all of b","The loop should use LENGTH(b) instead of LENGTH(a)","result should contain a and b separately, not sums"],"correctIndex":0}
{"prompt":"Hard 98 (procedures + lists): countGreaterThanNext should count positions where list[i] is greater than list[i+1]. Why does it miss the last comparison?","code":"PROCEDURE countGreaterThanNext(list) {\n  index ← 1\n  count ← 0\n  REPEAT UNTIL (index > LENGTH(list)) {\n    IF (list[index] > list[index + 1]) {\n      count ← count + 1\n    }\n    index ← index + 1\n  }\n  RETURN(count)\n}\nvals ← [3, 2, 1]\nDISPLAY(countGreaterThanNext(vals))","choices":["When index is at the last element, list[index + 1] is out of range, so the loop should stop earlier","The IF should use list[index] < list[index + 1]","count must start at 1","The loop should start at index 2"],"correctIndex":0}
{"prompt":"Hard 99 (procedures + lists): buildIndexList should return [1, 2, ..., LENGTH(list)]. Why is the list empty?","code":"PROCEDURE buildIndexList(list) {\n  result ← []\n  index ← 1\n  REPEAT UNTIL (index > LENGTH(result)) {\n    APPEND(result, index)\n    index ← index + 1\n  }\n  RETURN(result)\n}\nvals ← [5, 6, 7]\nDISPLAY(buildIndexList(vals))","choices":["The loop condition depends on LENGTH(result), which starts at 0, so the body never runs","It should append list[index] instead of the index itself","index must start at 0 instead of 1","The procedure must modify list instead of returning a new list"],"correctIndex":0}
{"prompt":"Hard 100 (procedures + lists): sumOddValues should return the sum of all odd values. Why does it always return 0?","code":"PROCEDURE sumOddValues(list) {\n  total ← 0\n  FOR EACH val IN list {\n    IF (val MOD 2 = 1) {\n      total ← total\n    }\n  }\n  RETURN(total)\n}\nvals ← [1, 3, 5]\nDISPLAY(sumOddValues(vals))","choices":["Inside the IF it never adds val to total, so total stays 0","The IF should use val MOD 2 = 0","total must start at the first list value","It should return the list of odd values instead of the sum"],"correctIndex":0}