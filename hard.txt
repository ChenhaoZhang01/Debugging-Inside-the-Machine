{"prompt":"Hard 01 (nested arrays): Why does this grid loop print the same row over and over?","code":"for (let i = 0; i < grid.length; i++) {\n  let row = grid[0];\n  for (let j = 0; j < row.length; j++) {\n    console.log(row[j]);\n  }\n}","choices":["It always uses grid[0] instead of grid[i], so every iteration prints the first row","j should be declared outside the loop","row.length must be grid.length","Nested loops cannot print 2D arrays"],"correctIndex":0}
{"prompt":"Hard 02 (nested arrays): Why is the zero count always wrong in this 2D loop?","code":"let count = 0;\nfor (let i = 0; i < cells.length; i++) {\n  for (let j = 0; j < cells.length; j++) {\n    if (cells[i][j] === 0) {\n      count++;\n    }\n  }\n}","choices":["The inner loop uses cells.length instead of cells[i].length, so row lengths are treated incorrectly","count must be inside the inner loop","0 cannot be stored in arrays","2D arrays must be flattened first"],"correctIndex":0}
{"prompt":"Hard 03 (nested loops): Why does this comparison miss many pairs of elements?","code":"for (let i = 0; i < arr.length; i++) {\n  for (let j = i; j < arr.length; j++) {\n    compare(arr[i], arr[j]);\n  }\n}","choices":["Starting j at i skips all pairs where j is less than i; if all ordered pairs are needed, j should start at 0","compare must be called once per element only","j must decrement, not increment","Nested loops cannot compare array items"],"correctIndex":0}
{"prompt":"Hard 04 (nested arrays): Why does this code crash on some rows when clearing a 2D map?","code":"for (let i = 0; i < map.length; i++) {\n  for (let j = 0; j < map[0].length; j++) {\n    map[i][j] = 0;\n  }\n}","choices":["It assumes every row has the same length as map[0]; it should use map[i].length","map[i][j] cannot be 0","i must start at 1","2D arrays cannot be modified in nested loops"],"correctIndex":0}
{"prompt":"Hard 05 (nested arrays): Why does this multiplication table contain only zeros?","code":"for (let i = 0; i < 10; i++) {\n  for (let j = 0; j < 10; j++) {\n    table[i][j] = i * 0;\n  }\n}","choices":["It multiplies by 0 instead of j; it should use i * j","table must be 1D","i must start at 1, not 0","Multiplication is not allowed in nested loops"],"correctIndex":0}
{"prompt":"Hard 06 (nested arrays): Why does this grid search keep scanning even after it finds the target?","code":"for (let i = 0; i < grid.length; i++) {\n  for (let j = 0; j < grid[i].length; j++) {\n    if (grid[i][j] === target) {\n      found = true;\n    }\n  }\n}","choices":["It never breaks out of the loops after finding the target, so it keeps scanning","target must be compared with ==","found must be declared inside the if","grid[i][j] cannot equal target"],"correctIndex":0}
{"prompt":"Hard 07 (nested arrays): Why do all values end up in the first row of B instead of matching rows in A?","code":"for (let i = 0; i < A.length; i++) {\n  for (let j = 0; j < A[i].length; j++) {\n    B[0][j] = A[i][j];\n  }\n}","choices":["The assignment always writes to row 0; it should write to B[i][j]","j should start at 1","A and B must be the same reference","2D arrays cannot be copied"],"correctIndex":0}
{"prompt":"Hard 08 (nested arrays): Why does this attempt to initialize a 2D grid throw 'cannot read length of undefined'?","code":"let grid = [];\nfor (let i = 0; i < rows; i++) {\n  for (let j = 0; j < grid[i].length; j++) {\n    grid[i][j] = 0;\n  }\n}","choices":["grid[i] is never initialized as an array before accessing grid[i].length","rows must be 0","j must start from 1","Arrays cannot contain arrays"],"correctIndex":0}
{"prompt":"Hard 09 (nested arrays): Why do these loops read outside the grid bounds?","code":"for (let i = 0; i <= grid.length; i++) {\n  for (let j = 0; j <= grid[i].length; j++) {\n    sum += grid[i][j];\n  }\n}","choices":["Using <= with length lets i and j reach one past the last valid index; it should use <","sum must be reset each row","grid[i].length must be grid.length","Nested loops cannot read from 2D arrays"],"correctIndex":0}
{"prompt":"Hard 10 (nested loops): Why does this 3D loop do more work than expected?","code":"for (let x = 0; x <= X; x++) {\n  for (let y = 0; y <= Y; y++) {\n    for (let z = 0; z <= Z; z++) {\n      visit(x, y, z);\n    }\n  }\n}","choices":["Using <= adds an extra iteration in each dimension; if bounds are counts, it should use <","visit must break out of all loops","x, y, z must be declared outside","3D loops are invalid in JS"],"correctIndex":0}
{"prompt":"Hard 11 (nested arrays): Why does this in-place transpose corrupt the matrix?","code":"for (let i = 0; i < m.length; i++) {\n  for (let j = 0; j < m[i].length; j++) {\n    m[i][j] = m[j][i];\n  }\n}","choices":["It overwrites values in-place without swapping using a temporary or separate matrix, corrupting data","i and j must start at 1","Transpose must be a built-in, not loops","2D arrays cannot be transposed"],"correctIndex":0}
{"prompt":"Hard 12 (nested arrays): Why does this diagonal fill produce solid rows instead of a diagonal?","code":"for (let i = 0; i < n; i++) {\n  for (let j = 0; j < n; j++) {\n    matrix[i][j] = 1;\n  }\n  if (i === j) {\n    matrix[i][j] = 1;\n  }\n}","choices":["The inner loop writes 1 to every cell; the diagonal condition must be inside the inner loop instead of writing everywhere","i === j is never true","matrix cannot be square","j must be declared outside the loop"],"correctIndex":0}
{"prompt":"Hard 13 (nested arrays): Why are row sums mixed up across indices?","code":"for (let i = 0; i < grid.length; i++) {\n  rowSums[i] = 0;\n  for (let j = 0; j < grid.length; j++) {\n    rowSums[j] += grid[i][j];\n  }\n}","choices":["The inner loop updates rowSums[j] instead of rowSums[i], mixing rows and columns","rowSums must be 2D","grid.length must be grid[i].length","+ cannot be used on arrays"],"correctIndex":0}
{"prompt":"Hard 14 (nested arrays): Why does this duplicate search always find a duplicate even when the array has unique values?","code":"for (let i = 0; i < arr.length; i++) {\n  for (let j = 0; j < arr.length; j++) {\n    if (arr[i] === arr[j]) {\n      foundDuplicate = true;\n    }\n  }\n}","choices":["It compares elements when i and j are equal, so each element matches itself; the code should skip cases where i === j","=== must be replaced with ==","arr.length must be arr.size","Arrays cannot contain unique values"],"correctIndex":0}
{"prompt":"Hard 15 (nested arrays): Why do we get stripes instead of a checkerboard pattern?","code":"for (let i = 0; i < rows; i++) {\n  for (let j = 0; j < cols; j++) {\n    if (i % 2 === 0) {\n      board[i][j] = 'black';\n    } else {\n      board[i][j] = 'white';\n    }\n  }\n}","choices":["The condition only depends on i; a checkerboard should depend on both i and j, for example (i + j) % 2","'black' and 'white' must be numbers","rows and cols must be equal","% cannot be used inside nested loops"],"correctIndex":0}
{"prompt":"Hard 16 (nested arrays): Why does only the last row seem to be copied correctly in this 2D copy attempt?","code":"let copy = [];\nfor (let i = 0; i < original.length; i++) {\n  let row = [];\n  copy.push(row);\n}\nfor (let j = 0; j < original[0].length; j++) {\n  copy[i][j] = original[i][j];\n}","choices":["The second loop uses i outside its scope and never loops rows again; it does not copy each row correctly","row must not be empty","original[0].length must be original.length","Arrays cannot be shallow copied"],"correctIndex":0}
{"prompt":"Hard 17 (nested arrays): Why does this code clear almost the whole matrix instead of just above the diagonal?","code":"for (let i = 0; i < n; i++) {\n  for (let j = 0; j < n; j++) {\n    if (j !== i) {\n      matrix[i][j] = 0;\n    }\n  }\n}","choices":["The condition clears everything except the diagonal; to clear only above it should check j > i","!== cannot be used with indices","i and j must start at 1","0 is not a valid matrix value"],"correctIndex":0}
{"prompt":"Hard 18 (nested arrays): Why does this code store row maxima instead of column maxima?","code":"for (let i = 0; i < grid.length; i++) {\n  let max = -Infinity;\n  for (let j = 0; j < grid[i].length; j++) {\n    if (grid[i][j] > max) {\n      max = grid[i][j];\n    }\n  }\n  columnMax[i] = max;\n}","choices":["It computes a maximum per row (i) and stores it in columnMax[i]; that is row-wise, not per column","-Infinity cannot be used","grid[i].length must be grid.length","columnMax must be 2D"],"correctIndex":0}
{"prompt":"Hard 19 (nested arrays): Why does this flattening code assume a square grid and misplace elements?","code":"let flat = [];\nfor (let i = 0; i < grid.length; i++) {\n  for (let j = 0; j < grid.length; j++) {\n    flat[i * grid.length + j] = grid[i][j];\n  }\n}","choices":["The inner loop uses grid.length instead of grid[i].length, assuming a square grid","flat must use push rather than index assignment","i * grid.length must be j * i","2D arrays cannot be flattened"],"correctIndex":0}
{"prompt":"Hard 20 (nested arrays): Why does this board equality check report equal when only one cell matches?","code":"let equal = false;\nfor (let i = 0; i < A.length; i++) {\n  for (let j = 0; j < A[i].length; j++) {\n    if (A[i][j] === B[i][j]) {\n      equal = true;\n      break;\n    }\n  }\n}","choices":["It sets equal to true on the first matching cell instead of checking all cells; it should look for mismatches instead","The break should be continue","=== must be ==","Boards cannot be compared"],"correctIndex":0}
{"prompt":"Hard 21 (nested arrays): Why does shifting tiles right overwrite values before they are moved?","code":"for (let i = 0; i < rows; i++) {\n  for (let j = 0; j < cols; j++) {\n    grid[i][j + 1] = grid[i][j];\n  }\n}","choices":["Iterating j from left to right overwrites cells before they can be read; it should loop j from right to left","j + 1 must be j - 1","rows must equal cols","Arrays cannot shift elements in loops"],"correctIndex":0}
{"prompt":"Hard 22 (nested arrays): Why does this rectangle clear sometimes go out of bounds?","code":"for (let i = top; i <= bottom; i++) {\n  for (let j = left; j <= right; j++) {\n    grid[i][j] = 0;\n  }\n}","choices":["Using inclusive <= bounds can overshoot if bottom or right are off by one; index checks or < may be needed","top must always be 0","grid must be 1D","Nested loops cannot write 0 into sub-rectangles"],"correctIndex":0}
{"prompt":"Hard 23 (nested arrays): Why does this same-row pair counter overcount duplicates?","code":"for (let i = 0; i < enemies.length; i++) {\n  for (let j = 0; j < enemies.length; j++) {\n    if (enemies[i].y === enemies[j].y) {\n      sameRowPairs++;\n    }\n  }\n}","choices":["It counts (i,j) and (j,i) and even pairs where i === j; it should restrict j to be greater than i","sameRowPairs must reset each loop",".y cannot be compared","Arrays cannot store objects"],"correctIndex":0}
{"prompt":"Hard 24 (nested arrays): Why does this adjacency matrix for an undirected graph only record edges in one direction?","code":"for (let i = 0; i < n; i++) {\n  for (let j = 0; j < n; j++) {\n    if (connected(i, j)) {\n      adj[i][j] = 1;\n    }\n  }\n}","choices":["For an undirected graph, the reverse entry adj[j][i] should also be set so the matrix is symmetric","i and j must start at 1","connected must be called once","Adjacency matrices cannot use 1s"],"correctIndex":0}
{"prompt":"Hard 25 (nested arrays): Why do column sums end up in the wrong indices?","code":"for (let i = 0; i < grid.length; i++) {\n  for (let j = 0; j < grid[i].length; j++) {\n    colSums[i] += grid[i][j];\n  }\n}","choices":["It adds to colSums[i] instead of colSums[j]; j is the column index","colSums must be 2D","grid[i].length must be grid.length","+ cannot be used with arrays"],"correctIndex":0}
{"prompt":"Hard 26 (nested arrays): Why does this normalization logic recompute a wrong sum after dividing?","code":"for (let i = 0; i < grid.length; i++) {\n  let sum = 0;\n  for (let j = 0; j < grid[i].length; j++) {\n    sum += grid[i][j];\n  }\n  for (let j = 0; j < grid[i].length; j++) {\n    grid[i][j] = grid[i][j] / sum;\n  }\n  for (let j = 0; j < grid[i].length; j++) {\n    sum += grid[i][j];\n  }\n}","choices":["The final loop reuses sum with already normalized values; that extra accumulation is incorrect or unnecessary","Division must happen outside the loops","sum must be global","Rows cannot be normalized separately"],"correctIndex":0}
{"prompt":"Hard 27 (nested arrays): Why can this search return stale or incorrect coordinates for the first empty cell?","code":"let foundI = -1;\nlet foundJ = -1;\nfor (let i = 0; i < board.length; i++) {\n  for (let j = 0; j < board[i].length; j++) {\n    if (board[i][j] === EMPTY) {\n      foundI = i;\n      foundJ = j;\n      break;\n    }\n  }\n}","choices":["Only the inner loop breaks; the outer loop continues and may overwrite or move past the first empty cell; it needs a second break or a flag","EMPTY cannot be compared","foundI and foundJ must be inside the inner loop","-1 is not a valid sentinel"],"correctIndex":0}
{"prompt":"Hard 28 (nested arrays): Why does this rotation look more like a transpose than a 90 degree rotation?","code":"for (let i = 0; i < n; i++) {\n  for (let j = 0; j < n; j++) {\n    rotated[j][i] = matrix[i][j];\n  }\n}","choices":["It only transposes (swaps i and j); a 90 degree rotation also needs to reverse rows or columns","rotated and matrix must be the same object","i and j must be swapped in the for headers","n must be matrix.length - 1"],"correctIndex":0}
{"prompt":"Hard 29 (nested arrays): Why is this matrix multiplication producing wrong numbers?","code":"for (let i = 0; i < A.length; i++) {\n  for (let j = 0; j < B[0].length; j++) {\n    let sum = 0;\n    for (let k = 0; k < B.length; k++) {\n      sum += A[i][k] * B[j][k];\n    }\n    C[i][j] = sum;\n  }\n}","choices":["The inner access B[j][k] uses the wrong indices; it should be B[k][j] for matrix multiplication","sum must be declared outside the loops","C must be 1D","Matrix multiplication cannot be written with loops"],"correctIndex":0}
{"prompt":"Hard 30 (nested arrays): Why does this clear-all-but-diagonal logic wipe out both above and below the diagonal instead of just above it?","code":"for (let i = 0; i < n; i++) {\n  for (let j = 0; j < n; j++) {\n    if (j !== i) {\n      matrix[i][j] = 0;\n    }\n  }\n}","choices":["The condition j !== i clears everything except the diagonal; to clear only above the diagonal it should use j > i","!== cannot be used with numbers","i and j must start at 1","matrix cannot store 0"],"correctIndex":0}
